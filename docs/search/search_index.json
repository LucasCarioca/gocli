{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"goCLI A simple and lightweight cli framework for go applications. Get your cli setup in seconds. Getting started Add the dependency go get github.com/LucasCarioca/gocli Your first cli package main import \"github.com/LucasCarioca/gocli/cli\" func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) }) app . Run () } Build and run go build main.go -o mycli mycli # Hello World","title":"Home"},{"location":"#gocli","text":"A simple and lightweight cli framework for go applications. Get your cli setup in seconds.","title":"goCLI"},{"location":"#getting-started","text":"Add the dependency go get github.com/LucasCarioca/gocli Your first cli package main import \"github.com/LucasCarioca/gocli/cli\" func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) }) app . Run () } Build and run go build main.go -o mycli mycli # Hello World","title":"Getting started"},{"location":"commands/","text":"General goCLI Commands are very simple and can be implemented in two different ways. The simplest is the functional command approach which is simply mapping a function to a command. The more full featured option is to create an implementation for the Command interface which can be more complex.","title":"General"},{"location":"commands/#general","text":"goCLI Commands are very simple and can be implemented in two different ways. The simplest is the functional command approach which is simply mapping a function to a command. The more full featured option is to create an implementation for the Command interface which can be more complex.","title":"General"},{"location":"commands/command-type/","text":"Command Type type Command interface { Run ( ctx AppInterface ) error } To implement the Command interface you need to create a struct with a public Run function that returns an error . For example: type ExampleCommand struct {} func ( * ExampleCommand ) Run ( _ cli . AppInterface ) error { fmt . Println ( \"This is the default command\" ) return nil } This approach allows for more complex implementations like the following example using flags type options struct { destroy bool add bool change bool } type ExampleCommand struct { Name : string } func ( c * ExampleCommand ) getOptions () * options { cmd := flag . NewFlagSet ( c . Name , flag . ExitOnError ) greet := cmd . Bool ( \"greet\" , false , \"Should the cli greet the user\" ) cmd . Parse ( os . Args [ 2 :]) return & options { greet : * greet , } } func ( c * ExampleCommand ) Run ( _ cli . AppInterface ) error { options := c . getOptions () if options . greet { fmt . Println ( \"Hello World\" ) } return nil }","title":"Command type"},{"location":"commands/command-type/#command-type","text":"type Command interface { Run ( ctx AppInterface ) error } To implement the Command interface you need to create a struct with a public Run function that returns an error . For example: type ExampleCommand struct {} func ( * ExampleCommand ) Run ( _ cli . AppInterface ) error { fmt . Println ( \"This is the default command\" ) return nil } This approach allows for more complex implementations like the following example using flags type options struct { destroy bool add bool change bool } type ExampleCommand struct { Name : string } func ( c * ExampleCommand ) getOptions () * options { cmd := flag . NewFlagSet ( c . Name , flag . ExitOnError ) greet := cmd . Bool ( \"greet\" , false , \"Should the cli greet the user\" ) cmd . Parse ( os . Args [ 2 :]) return & options { greet : * greet , } } func ( c * ExampleCommand ) Run ( _ cli . AppInterface ) error { options := c . getOptions () if options . greet { fmt . Println ( \"Hello World\" ) } return nil }","title":"Command Type"},{"location":"commands/functional-commands/","text":"Functional Commands type FunctionalCommand func ( ctx AppInterface ) error The simplest option is to just create a function and map it to a command in the app. You can do this by declaring the function seperately or passing an inline anonymous function. For example we can create a simple function and use it as the default command: func MyFunctionalCommand ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) } func main () { app := cli . NewApp ( MyFunctionalCommand ) app . Run () } Or similarly we could pass it in line as an anonymous function: func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) }) app . Run () } You can also pass as many commands as you want to map: func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"This is default command\" ) }) app . AddCommand ( \"hello\" , func ( _ cli . AppInterface ) error { fmt . Println ( \"This is hello command\" ) }) app . Run () }","title":"Functional commands"},{"location":"commands/functional-commands/#functional-commands","text":"type FunctionalCommand func ( ctx AppInterface ) error The simplest option is to just create a function and map it to a command in the app. You can do this by declaring the function seperately or passing an inline anonymous function. For example we can create a simple function and use it as the default command: func MyFunctionalCommand ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) } func main () { app := cli . NewApp ( MyFunctionalCommand ) app . Run () } Or similarly we could pass it in line as an anonymous function: func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"Hello world\" ) }) app . Run () } You can also pass as many commands as you want to map: func main () { app := cli . NewApp ( func ( _ cli . AppInterface ) error { fmt . Println ( \"This is default command\" ) }) app . AddCommand ( \"hello\" , func ( _ cli . AppInterface ) error { fmt . Println ( \"This is hello command\" ) }) app . Run () }","title":"Functional Commands"},{"location":"life-cycle-hooks/","text":"General goCLI offers some basic life cycle hooks at the command level. These should help in organizing your code structure in a more flexible way. More hooks are planned but at this time we only support setup and teardown hooks for commands.","title":"General"},{"location":"life-cycle-hooks/#general","text":"goCLI offers some basic life cycle hooks at the command level. These should help in organizing your code structure in a more flexible way. More hooks are planned but at this time we only support setup and teardown hooks for commands.","title":"General"},{"location":"life-cycle-hooks/setup-and-teardown/","text":"Setup and Teardown type CommandSetup interface { Setup ( ctx AppInterface ) error } type CommandTeardown interface { Teardown ( ctx AppInterface ) error } If you would like to organize your command into steps you can also use the provided CommandSetup and CommandTeardown types. If you command conforms to these interfaces you can add functions to be executed before and after the main Run function is executed. Both interfaces are optional and can be combined. For example type myCommand struct {} //Setup function to run before running the command func ( * myCommand ) Setup ( _ cli . AppInterface ) error { fmt . Println ( \"Setting up\" ) return nil } //Run command to run func ( * myCommand ) Run ( _ cli . AppInterface ) error { fmt . Println ( \"Running the command\" ) return nil } //Teardown function to run after running the command func ( * myCommand ) Teardown ( _ cli . AppInterface ) error { fmt . Println ( \"Tearing down\" ) return nil } The above example creates a command that implements Command , CommandSetup , and CommandTeardown interfaces. This allows it to use both lifecycle hooks.","title":"Setup and teardown"},{"location":"life-cycle-hooks/setup-and-teardown/#setup-and-teardown","text":"type CommandSetup interface { Setup ( ctx AppInterface ) error } type CommandTeardown interface { Teardown ( ctx AppInterface ) error } If you would like to organize your command into steps you can also use the provided CommandSetup and CommandTeardown types. If you command conforms to these interfaces you can add functions to be executed before and after the main Run function is executed. Both interfaces are optional and can be combined. For example type myCommand struct {} //Setup function to run before running the command func ( * myCommand ) Setup ( _ cli . AppInterface ) error { fmt . Println ( \"Setting up\" ) return nil } //Run command to run func ( * myCommand ) Run ( _ cli . AppInterface ) error { fmt . Println ( \"Running the command\" ) return nil } //Teardown function to run after running the command func ( * myCommand ) Teardown ( _ cli . AppInterface ) error { fmt . Println ( \"Tearing down\" ) return nil } The above example creates a command that implements Command , CommandSetup , and CommandTeardown interfaces. This allows it to use both lifecycle hooks.","title":"Setup and Teardown"}]}